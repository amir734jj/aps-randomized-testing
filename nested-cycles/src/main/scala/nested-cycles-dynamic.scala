// Generated by aps2scala version 0.3.6
import basic_implicit._;
object nested_cycles_dynamic_implicit {
  val nested_cycles_dynamic_loaded = true;
  import simple_implicit._;
  type T_NESTED_CYCLES[T_T] = T_T;
}
import nested_cycles_dynamic_implicit._;

import simple_implicit._;
trait C_NESTED_CYCLES_DYNAMIC[T_Result, T_T] extends C_TYPE[T_Result] with C_SIMPLE[T_Result] {
  type T_Names;
  val t_Names : C_TYPE[T_Names]with C_SET[T_Names,T_String];
  type T_NamesLattice;
  val t_NamesLattice : C_TYPE[T_NamesLattice]with C_UNION_LATTICE[T_NamesLattice,T_String,T_Names];
  def v_all_names : T_Names;
  val v_stmt_assigned_in : (T_Stmt) => T_NamesLattice;
  val v_stmts_assigned_in : (T_Stmts) => T_NamesLattice;
  val v_decl_assigned_in : (T_Decl) => T_NamesLattice;
  val v_decls_assigned_in : (T_Decls) => T_NamesLattice;
  val v_stmt_assigned_out : (T_Stmt) => T_NamesLattice;
  val v_stmts_assigned_out : (T_Stmts) => T_NamesLattice;
  val v_names_used : (T_Expr) => T_Names;
  val v_outer_names : (T_Block) => T_Names;
  type T_Messages;
  val t_Messages : C_TYPE[T_Messages]with C_SET[T_Messages,T_String];
  def v_msgs : T_Messages;
}

class M_NESTED_CYCLES_DYNAMIC[T_T](name : String,val t_T : C_TYPE[T_T] with C_SIMPLE[T_T])
  extends Module(name)
    with C_NESTED_CYCLES_DYNAMIC[T_T,T_T]
{
  type T_Result = T_T;
  val v_equal = t_T.v_equal;
  val v_string = t_T.v_string;
  val v_assert = t_T.v_assert;
  val v_node_equivalent = t_T.v_node_equivalent;
  type T_Program = t_T.T_Program;
  val t_Program = t_T.t_Program;
  type T_Block = t_T.T_Block;
  val t_Block = t_T.t_Block;
  type T_Decls = t_T.T_Decls;
  val t_Decls = t_T.t_Decls;
  type T_Decl = t_T.T_Decl;
  val t_Decl = t_T.t_Decl;
  type T_Type = t_T.T_Type;
  val t_Type = t_T.t_Type;
  type T_Stmts = t_T.T_Stmts;
  val t_Stmts = t_T.t_Stmts;
  type T_Stmt = t_T.T_Stmt;
  val t_Stmt = t_T.t_Stmt;
  type T_Expr = t_T.T_Expr;
  val t_Expr = t_T.t_Expr;
  val p_program = t_T.p_program;
  val v_program = t_T.v_program;
  val p_block = t_T.p_block;
  val v_block = t_T.v_block;
  val p_no_decls = t_T.p_no_decls;
  val v_no_decls = t_T.v_no_decls;
  val p_xcons_decls = t_T.p_xcons_decls;
  val v_xcons_decls = t_T.v_xcons_decls;
  val p_decl = t_T.p_decl;
  val v_decl = t_T.v_decl;
  val p_integer_type = t_T.p_integer_type;
  val v_integer_type = t_T.v_integer_type;
  val p_string_type = t_T.p_string_type;
  val v_string_type = t_T.v_string_type;
  val p_no_stmts = t_T.p_no_stmts;
  val v_no_stmts = t_T.v_no_stmts;
  val p_xcons_stmts = t_T.p_xcons_stmts;
  val v_xcons_stmts = t_T.v_xcons_stmts;
  val p_block_stmt = t_T.p_block_stmt;
  val v_block_stmt = t_T.v_block_stmt;
  val p_assign_stmt = t_T.p_assign_stmt;
  val v_assign_stmt = t_T.v_assign_stmt;
  val p_intconstant = t_T.p_intconstant;
  val v_intconstant = t_T.v_intconstant;
  val p_strconstant = t_T.p_strconstant;
  val v_strconstant = t_T.v_strconstant;
  val p_variable = t_T.p_variable;
  val v_variable = t_T.v_variable;

  val t_Result : this.type = this;
  val t_Names = new M_SET[T_String]("Names",t_String)

  type T_Names = /*TI*/T_SET[T_String];
  val t_NamesLattice = new M_UNION_LATTICE[T_String,T_Names]("NamesLattice",t_String,t_Names)
    /* dumping traits */
    with C_SET[T_Names, T_String]
    with C_TYPE[T_Names] {
    override val v_equal = t_Names.v_equal;
    override val v_less = t_Names.v_less;
    override val v_less_equal = t_Names.v_less_equal;
    override val v_none = t_Names.v_none;
    override val v_single = t_Names.v_single;
    override val v_append = t_Names.v_append;
    override val v__op_AC = t_Names.v__op_AC;
    override val p__op_AC = t_Names.p__op_AC;
    override val v_member = t_Names.v_member;
    override val v_union = t_Names.v_union;
    override val v_intersect = t_Names.v_intersect;
    override val v_difference = t_Names.v_difference;
    override val v_combine = t_Names.v_combine;
    override val v_assert = t_Names.v_assert;
    override val v_node_equivalent = t_Names.v_node_equivalent;
    override val v_string = t_Names.v_string;
  }

  type T_NamesLattice = /*TI*/T_UNION_LATTICE[T_String,T_Names];
  private class E_all_names(anchor : Null) extends Evaluation[Null,T_Names](anchor,"all_names") with CollectionEvaluation[Null,T_Names] {
    override def initial : T_Names = t_Names.v_initial;
    override def combine(v1 : T_Names, v2 : T_Names) = t_Names.v_combine(v1,v2);
    override def compute : ValueType = c_all_names();
  }
  private object a_all_names extends E_all_names(null) {}
  def v_all_names:T_Names = a_all_names.get;

  private class E_stmt_assigned_in(anchor : T_Stmt) extends Evaluation[T_Stmt,T_NamesLattice](anchor,anchor.toString()+"."+"stmt_assigned_in") with CircularEvaluation[T_Stmt,T_NamesLattice] {
    def lattice() : C_LATTICE[T_NamesLattice] = t_NamesLattice;

    override def compute : ValueType = c_stmt_assigned_in(anchor);
  }
  private object a_stmt_assigned_in extends Attribute[T_Stmt,T_NamesLattice](t_Stmt,t_NamesLattice,"stmt_assigned_in") {
    override def createEvaluation(anchor : T_Stmt) : Evaluation[T_Stmt,T_NamesLattice] = new E_stmt_assigned_in(anchor);
  }
  val v_stmt_assigned_in : T_Stmt => T_NamesLattice = a_stmt_assigned_in.get _;

  private class E_stmts_assigned_in(anchor : T_Stmts) extends Evaluation[T_Stmts,T_NamesLattice](anchor,anchor.toString()+"."+"stmts_assigned_in") with CircularEvaluation[T_Stmts,T_NamesLattice] {
    def lattice() : C_LATTICE[T_NamesLattice] = t_NamesLattice;

    override def compute : ValueType = c_stmts_assigned_in(anchor);
  }
  private object a_stmts_assigned_in extends Attribute[T_Stmts,T_NamesLattice](t_Stmts,t_NamesLattice,"stmts_assigned_in") {
    override def createEvaluation(anchor : T_Stmts) : Evaluation[T_Stmts,T_NamesLattice] = new E_stmts_assigned_in(anchor);
  }
  val v_stmts_assigned_in : T_Stmts => T_NamesLattice = a_stmts_assigned_in.get _;

  private class E_decl_assigned_in(anchor : T_Decl) extends Evaluation[T_Decl,T_NamesLattice](anchor,anchor.toString()+"."+"decl_assigned_in") {
    override def compute : ValueType = c_decl_assigned_in(anchor);
  }
  private object a_decl_assigned_in extends Attribute[T_Decl,T_NamesLattice](t_Decl,t_NamesLattice,"decl_assigned_in") {
    override def createEvaluation(anchor : T_Decl) : Evaluation[T_Decl,T_NamesLattice] = new E_decl_assigned_in(anchor);
  }
  val v_decl_assigned_in : T_Decl => T_NamesLattice = a_decl_assigned_in.get _;

  private class E_decls_assigned_in(anchor : T_Decls) extends Evaluation[T_Decls,T_NamesLattice](anchor,anchor.toString()+"."+"decls_assigned_in") {
    override def compute : ValueType = c_decls_assigned_in(anchor);
  }
  private object a_decls_assigned_in extends Attribute[T_Decls,T_NamesLattice](t_Decls,t_NamesLattice,"decls_assigned_in") {
    override def createEvaluation(anchor : T_Decls) : Evaluation[T_Decls,T_NamesLattice] = new E_decls_assigned_in(anchor);
  }
  val v_decls_assigned_in : T_Decls => T_NamesLattice = a_decls_assigned_in.get _;

  private class E_stmt_assigned_out(anchor : T_Stmt) extends Evaluation[T_Stmt,T_NamesLattice](anchor,anchor.toString()+"."+"stmt_assigned_out") with CircularEvaluation[T_Stmt,T_NamesLattice] {
    def lattice() : C_LATTICE[T_NamesLattice] = t_NamesLattice;

    override def compute : ValueType = c_stmt_assigned_out(anchor);
  }
  private object a_stmt_assigned_out extends Attribute[T_Stmt,T_NamesLattice](t_Stmt,t_NamesLattice,"stmt_assigned_out") {
    override def createEvaluation(anchor : T_Stmt) : Evaluation[T_Stmt,T_NamesLattice] = new E_stmt_assigned_out(anchor);
  }
  val v_stmt_assigned_out : T_Stmt => T_NamesLattice = a_stmt_assigned_out.get _;

  private class E_stmts_assigned_out(anchor : T_Stmts) extends Evaluation[T_Stmts,T_NamesLattice](anchor,anchor.toString()+"."+"stmts_assigned_out") with CircularEvaluation[T_Stmts,T_NamesLattice] {
    def lattice() : C_LATTICE[T_NamesLattice] = t_NamesLattice;

    override def compute : ValueType = c_stmts_assigned_out(anchor);
  }
  private object a_stmts_assigned_out extends Attribute[T_Stmts,T_NamesLattice](t_Stmts,t_NamesLattice,"stmts_assigned_out") {
    override def createEvaluation(anchor : T_Stmts) : Evaluation[T_Stmts,T_NamesLattice] = new E_stmts_assigned_out(anchor);
  }
  val v_stmts_assigned_out : T_Stmts => T_NamesLattice = a_stmts_assigned_out.get _;

  private class E_names_used(anchor : T_Expr) extends Evaluation[T_Expr,T_Names](anchor,anchor.toString()+"."+"names_used") {
    override def compute : ValueType = c_names_used(anchor);
  }
  private object a_names_used extends Attribute[T_Expr,T_Names](t_Expr,t_Names,"names_used") {
    override def createEvaluation(anchor : T_Expr) : Evaluation[T_Expr,T_Names] = new E_names_used(anchor);
  }
  val v_names_used : T_Expr => T_Names = a_names_used.get _;

  private class E_outer_names(anchor : T_Block) extends Evaluation[T_Block,T_Names](anchor,anchor.toString()+"."+"outer_names") {
    override def compute : ValueType = c_outer_names(anchor);
  }
  private object a_outer_names extends Attribute[T_Block,T_Names](t_Block,t_Names,"outer_names") {
    override def createEvaluation(anchor : T_Block) : Evaluation[T_Block,T_Names] = new E_outer_names(anchor);
  }
  val v_outer_names : T_Block => T_Names = a_outer_names.get _;

  val t_Messages = new M_SET[T_String]("Messages",t_String)

  type T_Messages = /*TI*/T_SET[T_String];
  private class E_msgs(anchor : Null) extends Evaluation[Null,T_Messages](anchor,"msgs") with CollectionEvaluation[Null,T_Messages] {
    override def initial : T_Messages = t_Messages.v_initial;
    override def combine(v1 : T_Messages, v2 : T_Messages) = t_Messages.v_combine(v1,v2);
    override def compute : ValueType = c_msgs();
  }
  private object a_msgs extends E_msgs(null) {}
  def v_msgs:T_Messages = a_msgs.get;

  private class E1_out(anchor : t_Result.T_Stmt) extends Evaluation[t_Result.T_Stmt,T_NamesLattice](anchor,anchor.toString()+"."+"out") with CircularEvaluation[t_Result.T_Stmt,T_NamesLattice] with CollectionEvaluation[t_Result.T_Stmt,T_NamesLattice] {
    override def initial : T_NamesLattice = t_NamesLattice.v_initial;
    override def combine(v1 : T_NamesLattice, v2 : T_NamesLattice) = t_NamesLattice.v_combine(v1,v2);
    def lattice() : C_LATTICE[T_NamesLattice] = t_NamesLattice;

    override def compute : ValueType = c1_out(anchor);
  }
  private object a1_out extends Attribute[t_Result.T_Stmt,T_NamesLattice](t_Result.t_Stmt,t_NamesLattice,"out") {
    override def createEvaluation(anchor : t_Result.T_Stmt) : Evaluation[t_Result.T_Stmt,T_NamesLattice] = new E1_out(anchor);
  }
  def c1_out(anchor : Any) : T_NamesLattice = {
    anchor match {
      case p_assign_stmt(v_s,v_e1,v_e2) => {
        var collection : T_NamesLattice = t_NamesLattice.v_initial;
        collection = t_NamesLattice.v_combine(collection,v_stmt_assigned_in(v_s));
        { val cond = new M__basic_3[ T_Names](t_Names).v__op_z0(v_names_used(v_e2),v_stmt_assigned_in(v_s));
          if (cond) {
            collection = t_NamesLattice.v_combine(collection,v_names_used(v_e1));
          }
        }
        return collection;
      }
    }
  }
  def c_stmt_assigned_in(anode : T_Stmt) : T_NamesLattice = {
    val anchor = anode.parent;
    if (!(anchor eq null)) {
      val anchorNodes = anchor.myType.nodes;
      if (anchorNodes == t_Result.t_Stmts.nodes) anchor match {
        case p_xcons_stmts(v_ss0,v_ss1,v_s) => {
          if (anode eq v_s) return v_stmts_assigned_out(v_ss1);
        }
        case _ => {}
      }
    }
    throw Evaluation.UndefinedAttributeException(anode.toString()+".stmt_assigned_in");
  }
  def c_stmts_assigned_in(anode : T_Stmts) : T_NamesLattice = {
    val anchor = anode.parent;
    if (!(anchor eq null)) {
      val anchorNodes = anchor.myType.nodes;
      if (anchorNodes == t_Result.t_Block.nodes) anchor match {
        case p_block(v_b,v_ds,v_ss) => {
          if (anode eq v_ss) return new M__basic_19[ T_String,T_NamesLattice](t_String,t_NamesLattice).v__op_w5D(v_stmts_assigned_out(v_ss),v_outer_names(v_b));
        }
        case _ => {}
      }
      if (anchorNodes == t_Result.t_Stmts.nodes) anchor match {
        case p_xcons_stmts(v_ss0,v_ss1,v_s) => {
          if (anode eq v_ss1) return v_stmts_assigned_in(v_ss0);
        }
        case _ => {}
      }
    }
    throw Evaluation.UndefinedAttributeException(anode.toString()+".stmts_assigned_in");
  }
  def c_decl_assigned_in(anode : T_Decl) : T_NamesLattice = {
    val anchor = anode.parent;
    if (!(anchor eq null)) {
      val anchorNodes = anchor.myType.nodes;
      if (anchorNodes == t_Result.t_Decls.nodes) anchor match {
        case p_xcons_decls(v_ds0,v_ds1,v_d) => {
          if (anode eq v_d) return v_decls_assigned_in(v_ds0);
        }
        case _ => {}
      }
    }
    throw Evaluation.UndefinedAttributeException(anode.toString()+".decl_assigned_in");
  }
  def c_decls_assigned_in(anode : T_Decls) : T_NamesLattice = {
    val anchor = anode.parent;
    if (!(anchor eq null)) {
      val anchorNodes = anchor.myType.nodes;
      if (anchorNodes == t_Result.t_Block.nodes) anchor match {
        case p_block(v_b,v_ds,v_ss) => {
          if (anode eq v_ds) return v_stmts_assigned_out(v_ss);
        }
        case _ => {}
      }
      if (anchorNodes == t_Result.t_Decls.nodes) anchor match {
        case p_xcons_decls(v_ds0,v_ds1,v_d) => {
          if (anode eq v_ds1) return v_decls_assigned_in(v_ds0);
        }
        case _ => {}
      }
    }
    throw Evaluation.UndefinedAttributeException(anode.toString()+".decls_assigned_in");
  }
  def c_stmt_assigned_out(anode : T_Stmt) : T_NamesLattice = {
    val anchor = anode;
    anchor match {
      case p_block_stmt(v_s,v_b) => {
        if (anode eq v_s) return v_stmt_assigned_in(v_s);
      }
      case _ => {}
    }
    anchor match {
      case p_assign_stmt(v_s,v_e1,v_e2) => {
        if (anode eq v_s) return a1_out.get(anchor);
      }
      case _ => {}
    }
    throw Evaluation.UndefinedAttributeException(anode.toString()+".stmt_assigned_out");
  }
  def c_stmts_assigned_out(anode : T_Stmts) : T_NamesLattice = {
    val anchor = anode;
    anchor match {
      case p_no_stmts(v_ss) => {
        if (anode eq v_ss) return v_stmts_assigned_in(v_ss);
      }
      case _ => {}
    }
    anchor match {
      case p_xcons_stmts(v_ss0,v_ss1,v_s) => {
        if (anode eq v_ss0) return v_stmt_assigned_out(v_s);
      }
      case _ => {}
    }
    throw Evaluation.UndefinedAttributeException(anode.toString()+".stmts_assigned_out");
  }
  def c_names_used(anode : T_Expr) : T_Names = {
    val anchor = anode;
    anchor match {
      case p_intconstant(v_e,v_0) => {
        if (anode eq v_e) return t_Names.v_none();
      }
      case _ => {}
    }
    anchor match {
      case p_strconstant(v_e,v_0) => {
        if (anode eq v_e) return t_Names.v_none();
      }
      case _ => {}
    }
    anchor match {
      case p_variable(v_e,v_id) => {
        if (anode eq v_e) return t_Names.v_single(v_id);
      }
      case _ => {}
    }
    throw Evaluation.UndefinedAttributeException(anode.toString()+".names_used");
  }
  def c_outer_names(anode : T_Block) : T_Names = {
    val anchor = anode.parent;
    if (!(anchor eq null)) {
      val anchorNodes = anchor.myType.nodes;
      if (anchorNodes == t_Result.t_Program.nodes) anchor match {
        case p_program(v_p,v_b) => {
          if (anode eq v_b) return t_Names.v_none();
        }
        case _ => {}
      }
      if (anchorNodes == t_Result.t_Stmt.nodes) anchor match {
        case p_block_stmt(v_s,v_b) => {
          if (anode eq v_b) return v_stmt_assigned_in(v_s);
        }
        case _ => {}
      }
    }
    throw Evaluation.UndefinedAttributeException(anode.toString()+".outer_names");
  }
  def c_all_names() : T_Names = {
    var collection : T_Names = t_Names.v_initial;
    for (anchor <- t_Result.t_Decl.nodes) anchor match {
      case p_decl(v_d,v_id,v_ty) => {
        collection = t_Names.v_combine(collection,t_Names.v_single(v_id));
      }
      case _ => {}
    }
    return collection;
  }
  def c_msgs() : T_Messages = {
    var collection : T_Messages = t_Messages.v_initial;
    for (anchor <- t_Result.t_Decl.nodes) anchor match {
      case p_decl(v_d,v_id,v_ty) => {
        { val cond = v_not(new M__basic_14[ T_String,T_NamesLattice](t_String,t_NamesLattice).v_in(v_id,v_decl_assigned_in(v_d)));
          if (cond) {
            collection = t_Messages.v_combine(collection,t_Messages.v_single(new M__basic_21[ T_String,T_Integer](t_String,t_Integer).v__op_BB(new M__basic_18[ T_String](t_String).v__op_ss(v_id," was not 'assigned.'"),new M__basic_24[ T_Decl](t_Decl).v_lineno(v_d))));
          }
        }
      }
      case _ => {}
    }
    return collection;
  }
  override def finish() : Unit = {
    a_all_names.get;
    a_stmt_assigned_in.finish;
    a_stmts_assigned_in.finish;
    a_decl_assigned_in.finish;
    a_decls_assigned_in.finish;
    a_stmt_assigned_out.finish;
    a_stmts_assigned_out.finish;
    a_names_used.finish;
    a_outer_names.finish;
    a_msgs.get;
    super.finish();
  }

}

